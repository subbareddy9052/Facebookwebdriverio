"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _teen_process = require("teen_process");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

var _logger = _interopRequireDefault(require("../logger.js"));

const PROCESS_INIT_TIMEOUT = 5000;

const COMPANION_PGREP_PATTERN = udid => `${_helpers.IDB_COMPANION_EXECUTABLE}.*--udid[[:space:]]+${udid}`;

const COMPANION_STARTUP_REGEXP = /Started GRPC server on port (\d+)/;
const COMPANION_STARTUP_ERROR_REGEXP = /New Error Built ==> (.+)/;

function buildDaemonArgs(opts = {}) {
  const {
    port,
    grpcPort
  } = opts;
  const result = ['daemon', '--notifier-path', _helpers.IDB_COMPANION_EXECUTABLE];

  if (port) {
    result.push('--port', port);
  }

  if (grpcPort) {
    result.push('--grpc-port', grpcPort);
  }

  return result;
}

const systemCallMethods = {};

systemCallMethods.connect = async function connect(opts = {}) {
  const {
    onlineTimeout
  } = opts;

  _logger.default.debug(`Connecting ${_helpers.IDB_EXECUTABLE} service to '${this.udid}'`);

  const binaryPaths = {};

  for (const binary of [_helpers.IDB_EXECUTABLE, _helpers.IDB_COMPANION_EXECUTABLE]) {
    try {
      binaryPaths[binary] = await _appiumSupport.fs.which(binary);
    } catch (e) {
      throw new Error(`'${binary}' has not been found in PATH. ` + `Is it installed? Read https://www.fbidb.io for more details`);
    }
  }

  let port = _helpers.DEFAULT_COMPANION_GRPC_PORT;

  try {
    _logger.default.debug(`Starting companion: '${binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE]}'`);

    const companionProc = new _teen_process.SubProcess(binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE], ['--udid', this.udid]);
    companionProc.on('exit', (code, signal) => {
      _logger.default.debug(`Companion exited with code '${code}' from signal '${signal}'`);
    });

    if (this.verbose) {
      companionProc.on('lines-stdout', function (lines) {
        for (let line of lines) {
          line = line.trim();

          if (line) {
            _logger.default.debug(`[Companion stdout] ${line}`);
          }
        }
      });
      companionProc.on('lines-stderr', function (lines) {
        for (let line of lines) {
          line = line.trim();

          if (line) {
            _logger.default.debug(`[Companion stderr] ${line}`);
          }
        }
      });
    }

    await companionProc.start(function (stdout, stderr) {
      const out = stdout || stderr;
      const readyMatch = COMPANION_STARTUP_REGEXP.exec(out);

      if (readyMatch) {
        port = readyMatch[1];
        return true;
      }

      const errorMatch = COMPANION_STARTUP_ERROR_REGEXP.exec(out);

      if (errorMatch) {
        throw new Error(errorMatch[1]);
      }

      return false;
    });
  } catch (err) {
    _logger.default.error(`Failed to start ${_helpers.IDB_COMPANION_EXECUTABLE}: ${err.message}`);

    throw err;
  }

  _logger.default.debug(`Companion running on port '${port}'`);

  try {
    try {
      await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', 'localhost', port]);
    } catch (connectionError) {
      await (0, _asyncbox.retryInterval)(2, 100, async () => {
        await this.disconnect();

        try {
          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['kill']);
        } catch (ign) {}

        let isStartupMonitorEnabled = true;

        try {
          const daemon = new _teen_process.SubProcess(_helpers.IDB_EXECUTABLE, buildDaemonArgs(this.executable));
          let daemonOutput = '';
          daemon.on('output', (stdout, stderr) => {
            if (isStartupMonitorEnabled && _lodash.default.trim(stdout || stderr)) {
              daemonOutput += `[daemon] ${stdout || stderr}\n`;
            }
          });

          try {
            await daemon.start(null, PROCESS_INIT_TIMEOUT);
            await _bluebird.default.delay(300);
          } catch (ign) {}

          if (daemon.isRunning) {
            _logger.default.debug(`${_helpers.IDB_EXECUTABLE} daemon started on port ${this.executable.port || _helpers.DEFAULT_IDB_PORT}`);
          } else {
            if (!daemonOutput.includes('address already in use')) {
              const message = `${_helpers.IDB_EXECUTABLE} daemon has failed to start: ${daemonOutput}`;

              _logger.default.warn(message);

              throw new Error(message);
            }

            _logger.default.debug(`The port ${this.executable.port || _helpers.DEFAULT_IDB_PORT} is already in use. ` + `Assuming it is used by ${_helpers.IDB_EXECUTABLE} daemon`);
          }

          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', this.udid]);
        } catch (connectionError2) {
          if (connectionError2.stderr || connectionError2.stdout) {
            _logger.default.debug(connectionError2.stderr || connectionError2.stdout);
          }

          throw connectionError2;
        } finally {
          isStartupMonitorEnabled = false;
        }
      });
    }
  } catch (e) {
    if (e.stderr) {
      _logger.default.debug(e.stderr);
    }

    throw new Error(`Cannot start ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'. ` + `Check the server log for more details.`);
  }

  _logger.default.info(`Successfully established the connection to ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'`);

  if (onlineTimeout) {
    await this.waitForDevice(onlineTimeout);
  }

  this.executable.path = binaryPaths[_helpers.IDB_EXECUTABLE];
  this.companion.path = binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE];
};

systemCallMethods.waitForDevice = async function waitForDevice(timeoutMs = 10000) {
  if (!timeoutMs) {
    _logger.default.debug('No timeout is provided, so not waiting until the device is online');

    return;
  }

  _logger.default.debug(`Waiting up to ${timeoutMs}ms for the device to be online`);

  const timer = new _appiumSupport.timing.Timer().start();

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        await this.exec(['ui', 'describe-all']);
        return true;
      } catch (e) {
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 300
    });
  } catch (e) {
    throw new Error(`The device '${this.udid}' is not responding to idb requests after ${timeoutMs}ms timeout. ` + `Original error: ${e.stderr || e.message}`);
  }

  _logger.default.debug(`The device '${this.udid}' is online and ready to accept idb commands in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);
};

systemCallMethods.disconnect = async function disconnect() {
  _logger.default.debug(`Disconnecting ${_helpers.IDB_EXECUTABLE} service from '${this.udid}'`);

  try {
    await (0, _teen_process.exec)(this.executable.path, ['disconnect', this.udid]);
  } catch (ign) {}

  const companionPids = await (0, _helpers.getPids)(COMPANION_PGREP_PATTERN(this.udid));

  if (_lodash.default.isEmpty(companionPids)) {
    return;
  }

  _logger.default.debug(`Cleaning up ${companionPids.length} obsolete ${_helpers.IDB_COMPANION_EXECUTABLE} ` + `process${companionPids.length === 1 ? '' : 'es'}`);

  await (0, _teen_process.exec)('kill', ['-2', ...companionPids]);
};

systemCallMethods.exec = async function exec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to exec()');
  }

  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.execTimeout || _helpers.DEFAULT_IDB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'execTimeout';
  const args = [...cmd, ...this.executable.defaultArgs];

  _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, args, opts);
    return stdout;
  } catch (e) {
    if (_appiumSupport.util.hasValue(e.code)) {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'; ` + `Stdout: '${(e.stdout || '').trim()}'; ` + `Stderr: '${(e.stderr || '').trim()}'; ` + `Code: '${e.code}'`;
    } else {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms ${_helpers.IDB_EXECUTABLE} execution timeout represented by '${opts.timeoutCapName}' capability`;
    }

    throw e;
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = [], opts = {}) {
  const idbArgs = [...args, ...this.executable.defaultArgs];

  _logger.default.debug(`Creating ${_helpers.IDB_EXECUTABLE} subprocess with args: ${(0, _shellQuote.quote)(args)}`);

  return new _teen_process.SubProcess(this.executable.path, idbArgs, opts);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY29tbWFuZHMuanMiXSwibmFtZXMiOlsiUFJPQ0VTU19JTklUX1RJTUVPVVQiLCJDT01QQU5JT05fUEdSRVBfUEFUVEVSTiIsInVkaWQiLCJJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEUiLCJDT01QQU5JT05fU1RBUlRVUF9SRUdFWFAiLCJDT01QQU5JT05fU1RBUlRVUF9FUlJPUl9SRUdFWFAiLCJidWlsZERhZW1vbkFyZ3MiLCJvcHRzIiwicG9ydCIsImdycGNQb3J0IiwicmVzdWx0IiwicHVzaCIsInN5c3RlbUNhbGxNZXRob2RzIiwiY29ubmVjdCIsIm9ubGluZVRpbWVvdXQiLCJsb2ciLCJkZWJ1ZyIsIklEQl9FWEVDVVRBQkxFIiwiYmluYXJ5UGF0aHMiLCJiaW5hcnkiLCJmcyIsIndoaWNoIiwiZSIsIkVycm9yIiwiREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JUIiwiY29tcGFuaW9uUHJvYyIsIlN1YlByb2Nlc3MiLCJvbiIsImNvZGUiLCJzaWduYWwiLCJ2ZXJib3NlIiwibGluZXMiLCJsaW5lIiwidHJpbSIsInN0YXJ0Iiwic3Rkb3V0Iiwic3RkZXJyIiwib3V0IiwicmVhZHlNYXRjaCIsImV4ZWMiLCJlcnJvck1hdGNoIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwiY29ubmVjdGlvbkVycm9yIiwiZGlzY29ubmVjdCIsImlnbiIsImlzU3RhcnR1cE1vbml0b3JFbmFibGVkIiwiZGFlbW9uIiwiZXhlY3V0YWJsZSIsImRhZW1vbk91dHB1dCIsIl8iLCJCIiwiZGVsYXkiLCJpc1J1bm5pbmciLCJERUZBVUxUX0lEQl9QT1JUIiwiaW5jbHVkZXMiLCJ3YXJuIiwiY29ubmVjdGlvbkVycm9yMiIsImluZm8iLCJ3YWl0Rm9yRGV2aWNlIiwicGF0aCIsImNvbXBhbmlvbiIsInRpbWVvdXRNcyIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiY29tcGFuaW9uUGlkcyIsImlzRW1wdHkiLCJsZW5ndGgiLCJjbWQiLCJpc0FycmF5IiwiY2xvbmVEZWVwIiwidGltZW91dCIsImV4ZWNUaW1lb3V0IiwiREVGQVVMVF9JREJfRVhFQ19USU1FT1VUIiwidGltZW91dENhcE5hbWUiLCJhcmdzIiwiZGVmYXVsdEFyZ3MiLCJ1dGlsIiwiaGFzVmFsdWUiLCJjcmVhdGVTdWJQcm9jZXNzIiwiaWRiQXJncyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFHQSxNQUFNQSxvQkFBb0IsR0FBRyxJQUE3Qjs7QUFDQSxNQUFNQyx1QkFBdUIsR0FBSUMsSUFBRCxJQUM3QixHQUFFQyxpQ0FBeUIsdUJBQXNCRCxJQUFLLEVBRHpEOztBQUVBLE1BQU1FLHdCQUF3QixHQUFHLG1DQUFqQztBQUNBLE1BQU1DLDhCQUE4QixHQUFHLDBCQUF2Qzs7QUFFQSxTQUFTQyxlQUFULENBQTBCQyxJQUFJLEdBQUcsRUFBakMsRUFBcUM7QUFDbkMsUUFBTTtBQUNKQyxJQUFBQSxJQURJO0FBRUpDLElBQUFBO0FBRkksTUFHRkYsSUFISjtBQUtBLFFBQU1HLE1BQU0sR0FBRyxDQUNiLFFBRGEsRUFFYixpQkFGYSxFQUVNUCxpQ0FGTixDQUFmOztBQUlBLE1BQUlLLElBQUosRUFBVTtBQUNSRSxJQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWSxRQUFaLEVBQXNCSCxJQUF0QjtBQUNEOztBQUNELE1BQUlDLFFBQUosRUFBYztBQUNaQyxJQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWSxhQUFaLEVBQTJCRixRQUEzQjtBQUNEOztBQUNELFNBQU9DLE1BQVA7QUFDRDs7QUFHRCxNQUFNRSxpQkFBaUIsR0FBRyxFQUExQjs7QUFvQkFBLGlCQUFpQixDQUFDQyxPQUFsQixHQUE0QixlQUFlQSxPQUFmLENBQXdCTixJQUFJLEdBQUcsRUFBL0IsRUFBbUM7QUFDN0QsUUFBTTtBQUNK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SCxJQUFqQixFQUF3QixLQUYxQixHQUdULFVBQVNYLENBQUMsQ0FBQ00sSUFBSyxHQUhuQjtBQUlELEtBTEQsTUFLTztBQUNMTixNQUFBQSxDQUFDLENBQUNxQixPQUFGLEdBQWEsbUJBQWtCMUIsdUJBQWUsc0JBQXFCSyxDQUFDLENBQUNxQixPQUFRLEtBQWpFLEdBQ1QsdUJBQXNCcEMsSUFBSSxDQUFDdUUsT0FBUSxNQUFLN0QsdUJBQWUsc0NBQXFDVixJQUFJLENBQUMwRSxjQUFlLGNBRG5IO0FBRUQ7O0FBQ0QsVUFBTTNELENBQU47QUFDRDtBQUNGLENBNUJEOztBQXFDQVYsaUJBQWlCLENBQUMwRSxnQkFBbEIsR0FBcUMsU0FBU0EsZ0JBQVQsQ0FBMkJKLElBQUksR0FBRyxFQUFsQyxFQUFzQzNFLElBQUksR0FBRyxFQUE3QyxFQUFpRDtBQUNwRixRQUFNZ0YsT0FBTyxHQUFHLENBQUMsR0FBR0wsSUFBSixFQUFVLEdBQUcsS0FBS2pDLFVBQUwsQ0FBZ0JrQyxXQUE3QixDQUFoQjs7QUFDQXBFLGtCQUFJQyxLQUFKLENBQVcsWUFBV0MsdUJBQWUsMEJBQXlCLHVCQUFNaUUsSUFBTixDQUFZLEVBQTFFOztBQUNBLFNBQU8sSUFBSXhELHdCQUFKLENBQWUsS0FBS3VCLFVBQUwsQ0FBZ0JZLElBQS9CLEVBQXFDMEIsT0FBckMsRUFBOENoRixJQUE5QyxDQUFQO0FBQ0QsQ0FKRDs7ZUFNZUssaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBmcywgdXRpbCwgdGltaW5nIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgZXhlYyBhcyB0cEV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCwgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7XG4gIGdldFBpZHMsIERFRkFVTFRfSURCX0VYRUNfVElNRU9VVCwgSURCX0VYRUNVVEFCTEUsXG4gIElEQl9DT01QQU5JT05fRVhFQ1VUQUJMRSwgREVGQVVMVF9JREJfUE9SVCwgREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JULFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcblxuXG5jb25zdCBQUk9DRVNTX0lOSVRfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBDT01QQU5JT05fUEdSRVBfUEFUVEVSTiA9ICh1ZGlkKSA9PlxuICBgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9LiotLXVkaWRbWzpzcGFjZTpdXSske3VkaWR9YDtcbmNvbnN0IENPTVBBTklPTl9TVEFSVFVQX1JFR0VYUCA9IC9TdGFydGVkIEdSUEMgc2VydmVyIG9uIHBvcnQgKFxcZCspLztcbmNvbnN0IENPTVBBTklPTl9TVEFSVFVQX0VSUk9SX1JFR0VYUCA9IC9OZXcgRXJyb3IgQnVpbHQgPT0+ICguKykvO1xuXG5mdW5jdGlvbiBidWlsZERhZW1vbkFyZ3MgKG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcG9ydCxcbiAgICBncnBjUG9ydCxcbiAgfSA9IG9wdHM7XG5cbiAgY29uc3QgcmVzdWx0ID0gW1xuICAgICdkYWVtb24nLFxuICAgICctLW5vdGlmaWVyLXBhdGgnLCBJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEUsXG4gIF07XG4gIGlmIChwb3J0KSB7XG4gICAgcmVzdWx0LnB1c2goJy0tcG9ydCcsIHBvcnQpO1xuICB9XG4gIGlmIChncnBjUG9ydCkge1xuICAgIHJlc3VsdC5wdXNoKCctLWdycGMtcG9ydCcsIGdycGNQb3J0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmNvbnN0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29ubmVjdE9wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG9ubGluZVRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiB1bnRpbCB0aGUgZGV2aWNlIHVuZGVyIHRlc3RzIGlzIG9ubGluZS4gTm8gd2FpdCBpcyBnb2luZyB0byBiZSBwZXJmb3JtZWRcbiAqIGlmIHRoZSB0aW1lb3V0IGlzIG5vdCBzZXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHByb3ZpZGUgdGhpcyB2YWx1ZSBpZlxuICogYGNvbm5lY3RgIGlzIGNhbGxlZCByaWdodCBhZnRlciBkZXZpY2UgaXMgYm9vdGVkLCBzbyBub3QgYWxsIHRoZSByZXF1aXJlZFxuICogZGV2aWNlIHNlcnZpY2VzIGhhdmUgYmVlbiBzdGFydGVkIHlldC5cbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGlkYiBhbmQgY29tcGFuaW9uIHByb2Nlc3NlcyBpZiBuZWNlc3NhcnkgYW5kXG4gKiBhc3NpZ25zIHBhdGggcHJvcGVydGllcy4gSXQgaXMgbWFuZGF0b3J5IHRvIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlXG4gKiBvbmUgY2FuIHN0YXJ0IHVzaW5nIElEQiBpbnN0YW5jZSxcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbWFuZGF0b3J5IGlkYiBleGVjdXRhYmxlcyBhcmUgbm90IHByZXNlbnQgb24gdGhlXG4gKiBsb2NhbGhvc3Qgb3IgdGhlcmUgd2FzIGEgZmFpbHVyZSB3aGlsZSBzdGFydGluZy9kZXRlY3RpbmcgdGhlbVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBvbmxpbmVUaW1lb3V0LFxuICB9ID0gb3B0cztcblxuICBsb2cuZGVidWcoYENvbm5lY3RpbmcgJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSB0byAnJHt0aGlzLnVkaWR9J2ApO1xuXG4gIGNvbnN0IGJpbmFyeVBhdGhzID0ge307XG4gIGZvciAoY29uc3QgYmluYXJ5IG9mIFtJREJfRVhFQ1VUQUJMRSwgSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFXSkge1xuICAgIHRyeSB7XG4gICAgICBiaW5hcnlQYXRoc1tiaW5hcnldID0gYXdhaXQgZnMud2hpY2goYmluYXJ5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2JpbmFyeX0nIGhhcyBub3QgYmVlbiBmb3VuZCBpbiBQQVRILiBgICtcbiAgICAgICAgYElzIGl0IGluc3RhbGxlZD8gUmVhZCBodHRwczovL3d3dy5mYmlkYi5pbyBmb3IgbW9yZSBkZXRhaWxzYCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHBvcnQgPSBERUZBVUxUX0NPTVBBTklPTl9HUlBDX1BPUlQ7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKGBTdGFydGluZyBjb21wYW5pb246ICcke2JpbmFyeVBhdGhzW0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRV19J2ApO1xuICAgIGNvbnN0IGNvbXBhbmlvblByb2MgPSBuZXcgU3ViUHJvY2VzcyhiaW5hcnlQYXRoc1tJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdLCBbJy0tdWRpZCcsIHRoaXMudWRpZF0pO1xuICAgIGNvbXBhbmlvblByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICBsb2cuZGVidWcoYENvbXBhbmlvbiBleGl0ZWQgd2l0aCBjb2RlICcke2NvZGV9JyBmcm9tIHNpZ25hbCAnJHtzaWduYWx9J2ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgY29tcGFuaW9uUHJvYy5vbignbGluZXMtc3Rkb3V0JywgZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgW0NvbXBhbmlvbiBzdGRvdXRdICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29tcGFuaW9uUHJvYy5vbignbGluZXMtc3RkZXJyJywgZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgW0NvbXBhbmlvbiBzdGRlcnJdICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IGNvbXBhbmlvblByb2Muc3RhcnQoZnVuY3Rpb24gKHN0ZG91dCwgc3RkZXJyKSB7XG4gICAgICBjb25zdCBvdXQgPSBzdGRvdXQgfHwgc3RkZXJyO1xuXG4gICAgICAvLyBjaGVjayBmb3IgbWFya2VyIHRoYXQgdGhpbmdzIGFyZSByZWFkeSB0byBnb1xuICAgICAgY29uc3QgcmVhZHlNYXRjaCA9IENPTVBBTklPTl9TVEFSVFVQX1JFR0VYUC5leGVjKG91dCk7XG4gICAgICBpZiAocmVhZHlNYXRjaCkge1xuICAgICAgICAvLyBmaW5kIHRoZSBwb3J0IGFuZCBzYXZlLCBzbyBpZGIgY2FuIGNvbm5lY3RcbiAgICAgICAgcG9ydCA9IHJlYWR5TWF0Y2hbMV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvclxuICAgICAgY29uc3QgZXJyb3JNYXRjaCA9IENPTVBBTklPTl9TVEFSVFVQX0VSUk9SX1JFR0VYUC5leGVjKG91dCk7XG4gICAgICBpZiAoZXJyb3JNYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNYXRjaFsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmVycm9yKGBGYWlsZWQgdG8gc3RhcnQgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgQ29tcGFuaW9uIHJ1bm5pbmcgb24gcG9ydCAnJHtwb3J0fSdgKTtcblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsnY29ubmVjdCcsICdsb2NhbGhvc3QnLCBwb3J0XSk7XG4gICAgfSBjYXRjaCAoY29ubmVjdGlvbkVycm9yKSB7XG4gICAgICBhd2FpdCByZXRyeUludGVydmFsKDIsIDEwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsna2lsbCddKTtcbiAgICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgICBsZXQgaXNTdGFydHVwTW9uaXRvckVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhZW1vbiA9IG5ldyBTdWJQcm9jZXNzKElEQl9FWEVDVVRBQkxFLCBidWlsZERhZW1vbkFyZ3ModGhpcy5leGVjdXRhYmxlKSk7XG4gICAgICAgICAgbGV0IGRhZW1vbk91dHB1dCA9ICcnO1xuICAgICAgICAgIGRhZW1vbi5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdGFydHVwTW9uaXRvckVuYWJsZWQgJiYgXy50cmltKHN0ZG91dCB8fCBzdGRlcnIpKSB7XG4gICAgICAgICAgICAgIGRhZW1vbk91dHB1dCArPSBgW2RhZW1vbl0gJHtzdGRvdXQgfHwgc3RkZXJyfVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGRhZW1vbi5zdGFydChudWxsLCBQUk9DRVNTX0lOSVRfVElNRU9VVCk7XG4gICAgICAgICAgICBhd2FpdCBCLmRlbGF5KDMwMCk7XG4gICAgICAgICAgfSBjYXRjaCAoaWduKSB7fVxuXG4gICAgICAgICAgaWYgKGRhZW1vbi5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgJHtJREJfRVhFQ1VUQUJMRX0gZGFlbW9uIHN0YXJ0ZWQgb24gcG9ydCAke3RoaXMuZXhlY3V0YWJsZS5wb3J0IHx8IERFRkFVTFRfSURCX1BPUlR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGFlbW9uT3V0cHV0LmluY2x1ZGVzKCdhZGRyZXNzIGFscmVhZHkgaW4gdXNlJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke0lEQl9FWEVDVVRBQkxFfSBkYWVtb24gaGFzIGZhaWxlZCB0byBzdGFydDogJHtkYWVtb25PdXRwdXR9YDtcbiAgICAgICAgICAgICAgbG9nLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgVGhlIHBvcnQgJHt0aGlzLmV4ZWN1dGFibGUucG9ydCB8fCBERUZBVUxUX0lEQl9QT1JUfSBpcyBhbHJlYWR5IGluIHVzZS4gYCArXG4gICAgICAgICAgICAgIGBBc3N1bWluZyBpdCBpcyB1c2VkIGJ5ICR7SURCX0VYRUNVVEFCTEV9IGRhZW1vbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsnY29ubmVjdCcsIHRoaXMudWRpZF0pO1xuICAgICAgICB9IGNhdGNoIChjb25uZWN0aW9uRXJyb3IyKSB7XG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb25FcnJvcjIuc3RkZXJyIHx8IGNvbm5lY3Rpb25FcnJvcjIuc3Rkb3V0KSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoY29ubmVjdGlvbkVycm9yMi5zdGRlcnIgfHwgY29ubmVjdGlvbkVycm9yMi5zdGRvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3IyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlzU3RhcnR1cE1vbml0b3JFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLnN0ZGVycikge1xuICAgICAgbG9nLmRlYnVnKGUuc3RkZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RhcnQgJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSBmb3IgJyR7dGhpcy51ZGlkfScuIGAgK1xuICAgICAgYENoZWNrIHRoZSBzZXJ2ZXIgbG9nIGZvciBtb3JlIGRldGFpbHMuYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aGUgY29ubmVjdGlvbiB0byAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIGZvciAnJHt0aGlzLnVkaWR9J2ApO1xuXG4gIGlmIChvbmxpbmVUaW1lb3V0KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRGV2aWNlKG9ubGluZVRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5leGVjdXRhYmxlLnBhdGggPSBiaW5hcnlQYXRoc1tJREJfRVhFQ1VUQUJMRV07XG4gIHRoaXMuY29tcGFuaW9uLnBhdGggPSBiaW5hcnlQYXRoc1tJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdO1xufTtcblxuLyoqXG4gKiBCbG9ja3MgdW50aWwgdGhlIGRldmljZSB1bmRlciB0ZXN0IHN0YXJ0cyByZXNwb25kaW5nIHRvIGlkYiBjb21tYW5kcy5cbiAqIFRoZSBkZXZpY2UgbXVzdCBiZSBib290ZWQvb25saW5lIGFuZCBpZGIgbXVzdCBiZSBhbHJlYWR5IGNvbm5lY3RlZCBmb3IgdGhhdCB0byBoYXBwZW5cbiAqXG4gKiBAcGFyYW0gez9udW1iZXJ9IHRpbWVvdXRNcyBbMTAwMDBdIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogdW50aWwgdGhlIGRldmljZSB1bmRlciB0ZXN0cyBpcyBvbmxpbmUuIFRoZSBtZXRob2Qgd2lsbCByZXR1cm4gaW1tZWRpYXRlbHlcbiAqIGlmIHRoZSB0aW1lb3V0IGlzIGZhbHN5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRldmljZSBpcyBub3QgcmVzcG9uZGluZyB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXRcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXZpY2UgKHRpbWVvdXRNcyA9IDEwMDAwKSB7XG4gIGlmICghdGltZW91dE1zKSB7XG4gICAgbG9nLmRlYnVnKCdObyB0aW1lb3V0IGlzIHByb3ZpZGVkLCBzbyBub3Qgd2FpdGluZyB1bnRpbCB0aGUgZGV2aWNlIGlzIG9ubGluZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXRNc31tcyBmb3IgdGhlIGRldmljZSB0byBiZSBvbmxpbmVgKTtcbiAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXhlYyhbJ3VpJywgJ2Rlc2NyaWJlLWFsbCddKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDMwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRldmljZSAnJHt0aGlzLnVkaWR9JyBpcyBub3QgcmVzcG9uZGluZyB0byBpZGIgcmVxdWVzdHMgYWZ0ZXIgJHt0aW1lb3V0TXN9bXMgdGltZW91dC4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5tZXNzYWdlfWApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgVGhlIGRldmljZSAnJHt0aGlzLnVkaWR9JyBpcyBvbmxpbmUgYW5kIHJlYWR5IHRvIGFjY2VwdCBpZGIgY29tbWFuZHMgaW4gYCArXG4gICAgYCR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zYCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGNsZWFudXAgb2Ygb2Jzb2xldGUgY29tcGFuaW9uIHByb2Nlc3Nlc1xuICogVGhlIGRhZW1vbiBwcm9jZXNzIGlzIGxlZnQgdW50b3VjaGVkLCBiZWNhdXNlIGtpbGxpbmcgaXQgbWlnaHRcbiAqIHBvdGVudGlhbGx5IGFmZmVjdCBvdGhlciBwYXJhbGxlbCBzZXNzaW9ucy4gTm90aGluZ1xuICogaXMgZG9uZSBpZiBubyBvYnNvbGV0ZSBwcm9jZXNzZXMgYXJlIGZvdW5kLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5kaXNjb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdCAoKSB7XG4gIGxvZy5kZWJ1ZyhgRGlzY29ubmVjdGluZyAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIGZyb20gJyR7dGhpcy51ZGlkfSdgKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRwRXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydkaXNjb25uZWN0JywgdGhpcy51ZGlkXSk7XG4gIH0gY2F0Y2ggKGlnbikge31cblxuICBjb25zdCBjb21wYW5pb25QaWRzID0gYXdhaXQgZ2V0UGlkcyhDT01QQU5JT05fUEdSRVBfUEFUVEVSTih0aGlzLnVkaWQpKTtcbiAgaWYgKF8uaXNFbXB0eShjb21wYW5pb25QaWRzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgQ2xlYW5pbmcgdXAgJHtjb21wYW5pb25QaWRzLmxlbmd0aH0gb2Jzb2xldGUgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9IGAgK1xuICAgIGBwcm9jZXNzJHtjb21wYW5pb25QaWRzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ2VzJ31gKTtcbiAgYXdhaXQgdHBFeGVjKCdraWxsJywgWyctMicsIC4uLmNvbXBhbmlvblBpZHNdKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gaWRiIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgIG9yIGEgc2luZ2xlIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcGFzcyBpbiBhIGNvbW1hbmQgdG8gZXhlYygpJyk7XG4gIH1cbiAgY21kID0gXy5pc0FycmF5KGNtZCkgPyBjbWQgOiBbY21kXTtcblxuICBvcHRzID0gXy5jbG9uZURlZXAob3B0cyk7XG4gIC8vIHNldHRpbmcgZGVmYXVsdCB0aW1lb3V0IGZvciBlYWNoIGNvbW1hbmQgdG8gcHJldmVudCBpbmZpbml0ZSB3YWl0LlxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy5leGVjVGltZW91dCB8fCBERUZBVUxUX0lEQl9FWEVDX1RJTUVPVVQ7XG4gIG9wdHMudGltZW91dENhcE5hbWUgPSBvcHRzLnRpbWVvdXRDYXBOYW1lIHx8ICdleGVjVGltZW91dCc7IC8vIEZvciBlcnJvciBtZXNzYWdlXG5cbiAgY29uc3QgYXJncyA9IFsuLi5jbWQsIC4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJnc107XG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0gJHtxdW90ZShhcmdzKX0nYCk7XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0cEV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIGFyZ3MsIG9wdHMpO1xuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodXRpbC5oYXNWYWx1ZShlLmNvZGUpKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nICR7SURCX0VYRUNVVEFCTEV9LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICBgU3Rkb3V0OiAnJHsoZS5zdGRvdXQgfHwgJycpLnRyaW0oKX0nOyBgICtcbiAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgYCArXG4gICAgICAgIGBDb2RlOiAnJHtlLmNvZGV9J2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgJHtJREJfRVhFQ1VUQUJMRX0uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9Jy4gYCArXG4gICAgICAgIGBUcnkgdG8gaW5jcmVhc2UgdGhlICR7b3B0cy50aW1lb3V0fW1zICR7SURCX0VYRUNVVEFCTEV9IGV4ZWN1dGlvbiB0aW1lb3V0IHJlcHJlc2VudGVkIGJ5ICcke29wdHMudGltZW91dENhcE5hbWV9JyBjYXBhYmlsaXR5YDtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFN1YlByb2Nlc3MgaW5zdGFuY2Ugb2YgaWRiIGZvciBiYWNrZ3JvdW5kXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBhcmdzIGFkZGl0aW9uYWwgaWRiIGFyZ3VtZW50c1xuICogQHJldHVybnMge1N1YlByb2Nlc3N9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVTdWJQcm9jZXNzIChhcmdzID0gW10sIG9wdHMgPSB7fSkge1xuICBjb25zdCBpZGJBcmdzID0gWy4uLmFyZ3MsIC4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJnc107XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgJHtJREJfRVhFQ1VUQUJMRX0gc3VicHJvY2VzcyB3aXRoIGFyZ3M6ICR7cXVvdGUoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgaWRiQXJncywgb3B0cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jb21tYW5kcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
